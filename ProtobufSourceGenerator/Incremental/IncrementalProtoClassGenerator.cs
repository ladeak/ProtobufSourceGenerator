using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace ProtobufSourceGenerator.Incremental;

internal sealed class IncrementalProtoClassGenerator
{
    public string CreateClass(ProtoClassDataModel classModel)
    {
        TypeDeclarationSyntax typeSyntax = GenerateType(classModel);

        int counter = 1;
        foreach (ProtoPropertyDataModel property in classModel.PropertyDataModels)
        {
            PropertyDeclarationSyntax newProperty = CreateSkeletonProperty(property);

            var (getter, setter) = CreateGetterSetter(property);

            while (classModel.UsedTags.Contains(counter))
                counter++;

            var protoMemberAttribute = SyntaxFactory.SingletonList(
                SyntaxFactory.AttributeList(
                    SyntaxFactory.SingletonSeparatedList(
                        SyntaxFactory.Attribute(
                            SyntaxFactory.QualifiedName(SyntaxFactory.AliasQualifiedName(
                                SyntaxFactory.IdentifierName(SyntaxFactory.Token(SyntaxKind.GlobalKeyword)), SyntaxFactory.IdentifierName("ProtoBuf")), SyntaxFactory.IdentifierName("ProtoMember")))
                        .WithArgumentList(
                            SyntaxFactory.AttributeArgumentList(
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.AttributeArgument(
                                        SyntaxFactory.LiteralExpression(
                                            SyntaxKind.NumericLiteralExpression,
                                            SyntaxFactory.Literal(counter++)))))))));

            newProperty = newProperty.WithAccessorList(SyntaxFactory.AccessorList(SyntaxFactory.List(new[] { getter, setter })))
            .NormalizeWhitespace().WithLeadingTrivia(SyntaxFactory.TriviaList(SyntaxFactory.Whitespace(" ")))
            .WithAttributeLists(protoMemberAttribute);

            typeSyntax = typeSyntax.WithMembers(typeSyntax.Members.Add(newProperty));
        }

        typeSyntax = typeSyntax.WithAttributeLists(SyntaxFactory.SingletonList(
            SyntaxFactory.AttributeList(SyntaxFactory.SingletonSeparatedList(
                SyntaxFactory.Attribute(
                    SyntaxFactory.QualifiedName(SyntaxFactory.QualifiedName(SyntaxFactory.QualifiedName(SyntaxFactory.AliasQualifiedName(
                                SyntaxFactory.IdentifierName(SyntaxFactory.Token(SyntaxKind.GlobalKeyword)), SyntaxFactory.IdentifierName("System")), SyntaxFactory.IdentifierName("Runtime")), SyntaxFactory.IdentifierName("CompilerServices")), SyntaxFactory.IdentifierName("CompilerGeneratedAttribute")))))));

        // For all parent types, we wrap the inner type
        while (classModel.Parent is { } parentClass)
        {
            var parentClassSyntax = GenerateType(parentClass);
            parentClassSyntax = parentClassSyntax.WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(typeSyntax));
            typeSyntax = parentClassSyntax;
            classModel = parentClass;
        }

        SyntaxNode rootDeclaration = typeSyntax;

        // Adding namespace to type when namespace is not global
        if (!string.IsNullOrWhiteSpace(classModel.Namespace))
        {
            var namespaceDeclaration = SyntaxFactory.FileScopedNamespaceDeclaration(SyntaxFactory.IdentifierName(classModel.Namespace));
            rootDeclaration = namespaceDeclaration.WithMembers(SyntaxFactory.SingletonList<MemberDeclarationSyntax>(typeSyntax));
        }

        // Adding nullability
        rootDeclaration = rootDeclaration.WithLeadingTrivia(SyntaxFactory.TriviaList(SyntaxFactory.Comment("// <auto-generated/>"), SyntaxFactory.Trivia(SyntaxFactory.NullableDirectiveTrivia(SyntaxFactory.Token(SyntaxKind.EnableKeyword), true))));
        return rootDeclaration.NormalizeWhitespace().ToFullString();
    }

    private PropertyDeclarationSyntax CreateSkeletonProperty(ProtoPropertyDataModel property) => property.Kind switch
    {
        ProtoPropertyDataModel.PropertyKind.None => CreateNormalSkeletonProperty(property),
        ProtoPropertyDataModel.PropertyKind.CollectionHelper => CreateHelperSkeletonProperty(property),
        ProtoPropertyDataModel.PropertyKind.EnumerationHelper => CreateHelperSkeletonProperty(property),
        _ => throw new InvalidOperationException("Proto property type kind supported"),
    };

    private PropertyDeclarationSyntax CreateNormalSkeletonProperty(ProtoPropertyDataModel property)
    {
        return SyntaxFactory.PropertyDeclaration(SyntaxFactory.ParseTypeName(property.PropertyTypeName),
          SyntaxFactory.Identifier(GetNormalPropertyName(property)))
          .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PrivateKeyword)));
    }

    private PropertyDeclarationSyntax CreateHelperSkeletonProperty(ProtoPropertyDataModel property)
    {
        return SyntaxFactory.PropertyDeclaration(SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.BoolKeyword)),
          SyntaxFactory.Identifier(GetIsEmptyPropertyName(property)))
          .WithModifiers(SyntaxFactory.TokenList(SyntaxFactory.Token(SyntaxKind.PrivateKeyword)));
    }

    private (AccessorDeclarationSyntax Getter, AccessorDeclarationSyntax Setter) CreateGetterSetter(ProtoPropertyDataModel property) => property.Kind switch
    {
        ProtoPropertyDataModel.PropertyKind.None => CreateNormalGetterSetter(property),
        ProtoPropertyDataModel.PropertyKind.CollectionHelper => CreateCollectionHelperGetterSetter(property),
        ProtoPropertyDataModel.PropertyKind.EnumerationHelper => CreateEnumerationHelperGetterSetter(property),
        _ => throw new InvalidOperationException("Proto property type kind supported"),
    };

    private (AccessorDeclarationSyntax Getter, AccessorDeclarationSyntax Setter) CreateNormalGetterSetter(ProtoPropertyDataModel property)
    {
        var getter = SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
          .WithExpressionBody(SyntaxFactory.ArrowExpressionClause(SyntaxFactory.IdentifierName(property.PropertyIdentifier)))
          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));
        var setter = SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
          .WithExpressionBody(SyntaxFactory.ArrowExpressionClause(SyntaxFactory.AssignmentExpression(
            SyntaxKind.SimpleAssignmentExpression,
            SyntaxFactory.IdentifierName(property.PropertyIdentifier),
            SyntaxFactory.IdentifierName("value"))))
          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

        return (getter, setter);
    }

    private (AccessorDeclarationSyntax Getter, AccessorDeclarationSyntax Setter) CreateCollectionHelperGetterSetter(ProtoPropertyDataModel property)
    {
        var getter = SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
          .WithExpressionBody(SyntaxFactory.ArrowExpressionClause(SyntaxFactory.BinaryExpression(SyntaxKind.EqualsExpression,
            SyntaxFactory.ConditionalAccessExpression(SyntaxFactory.IdentifierName(GetNormalPropertyName(property)), SyntaxFactory.MemberBindingExpression(SyntaxFactory.IdentifierName("Count"))),
            SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(0)))))
          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

        var setter = SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
            .WithBody(SyntaxFactory.Block(SyntaxFactory.SingletonList<StatementSyntax>(
                                SyntaxFactory.IfStatement(SyntaxFactory.IdentifierName("value"),
                                SyntaxFactory.ExpressionStatement(
                                    SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, SyntaxFactory.IdentifierName(GetNormalPropertyName(property)), SyntaxFactory.ImplicitObjectCreationExpression()))))));

        return (getter, setter);
    }

    private (AccessorDeclarationSyntax Getter, AccessorDeclarationSyntax Setter) CreateEnumerationHelperGetterSetter(ProtoPropertyDataModel property)
    {
        var getter = SyntaxFactory.AccessorDeclaration(SyntaxKind.GetAccessorDeclaration)
          .WithExpressionBody(SyntaxFactory.ArrowExpressionClause(
              SyntaxFactory.BinaryExpression(SyntaxKind.LogicalAndExpression,
              SyntaxFactory.BinaryExpression(SyntaxKind.NotEqualsExpression, SyntaxFactory.IdentifierName(GetNormalPropertyName(property)), SyntaxFactory.LiteralExpression(SyntaxKind.NullLiteralExpression)),
              SyntaxFactory.InvocationExpression(SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                  SyntaxFactory.IdentifierName("System"), SyntaxFactory.IdentifierName("Linq")), SyntaxFactory.IdentifierName("Enumerable")), SyntaxFactory.IdentifierName("Any")))
                  .WithArgumentList(SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList<ArgumentSyntax>(SyntaxFactory.Argument(SyntaxFactory.IdentifierName(GetNormalPropertyName(property)))))))))
          .WithSemicolonToken(SyntaxFactory.Token(SyntaxKind.SemicolonToken));

        var setter = SyntaxFactory.AccessorDeclaration(SyntaxKind.SetAccessorDeclaration)
          .WithBody(SyntaxFactory.Block(SyntaxFactory.SingletonList<StatementSyntax>(SyntaxFactory.IfStatement(SyntaxFactory.IdentifierName("value"),
                                    SyntaxFactory.ExpressionStatement(
                                        SyntaxFactory.AssignmentExpression(SyntaxKind.SimpleAssignmentExpression, SyntaxFactory.IdentifierName(GetNormalPropertyName(property)),
                                            SyntaxFactory.InvocationExpression(GetEnumerableEmpty(property))))))));

        return (getter, setter);
    }

    private static TypeDeclarationSyntax GenerateType(ProtoClassDataModel classModel)
    {
        TypeDeclarationSyntax type = classModel switch
        {
            { IsRecord: true, IsReferenceType: true } => SyntaxFactory.RecordDeclaration(SyntaxFactory.Token(SyntaxKind.RecordKeyword), classModel.Name).WithClassOrStructKeyword(SyntaxFactory.Token(SyntaxKind.ClassKeyword)).WithOpenBraceToken(SyntaxFactory.Token(SyntaxKind.OpenBraceToken)).WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken)),
            { IsRecord: true, IsReferenceType: false } => SyntaxFactory.RecordDeclaration(SyntaxFactory.Token(SyntaxKind.RecordKeyword), classModel.Name).WithClassOrStructKeyword(SyntaxFactory.Token(SyntaxKind.StructDeclaration)).WithOpenBraceToken(SyntaxFactory.Token(SyntaxKind.OpenBraceToken)).WithCloseBraceToken(SyntaxFactory.Token(SyntaxKind.CloseBraceToken)),
            { IsReferenceType: false } => SyntaxFactory.StructDeclaration(classModel.Name),
            _ => SyntaxFactory.ClassDeclaration(classModel.Name),
        };

        return type.WithModifiers(
            SyntaxFactory.TokenList(
                new[] {
                    SyntaxFactory.Token(SyntaxKind.PublicKeyword),
                    SyntaxFactory.Token(SyntaxKind.PartialKeyword)
                }));
    }

    private static string GetNormalPropertyName(ProtoPropertyDataModel property) => $"Proto{property.PropertyIdentifier}";

    private static string GetIsEmptyPropertyName(ProtoPropertyDataModel property) => $"ProtoIsEmpty{property.PropertyIdentifier}";

    private static MemberAccessExpressionSyntax GetEnumerableEmpty(ProtoPropertyDataModel property) =>
        SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
            SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                    SyntaxFactory.IdentifierName("System"), SyntaxFactory.IdentifierName("Linq")), SyntaxFactory.IdentifierName("Enumerable")),
            SyntaxFactory.GenericName(SyntaxFactory.Identifier("Empty"))
            .WithTypeArgumentList(SyntaxFactory.TypeArgumentList(SyntaxFactory.SingletonSeparatedList<TypeSyntax>(SyntaxFactory.ParseTypeName(property.GenertyTypeParameter)))));
}